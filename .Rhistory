max()
latex <- str_c(latex, "\t\t\tS[table-format = ", numCount ,".2]\n", sep="")
}
latex <- str_c(latex, "\t\t\t|}\n\t\\hline\n\t\t", sep="")
if (col_count > 2)
{
for (i in seq(1,col_count))
{
if (i == 1)
latex <- str_c(latex, "\\textbf{Estatística}", sep="")
else
latex <- str_c(latex, " \\textbf{", data[1, i], "}", sep="")
if (i < col_count)
latex <- str_c(latex, "&", sep=" ")
else
latex <- str_c(latex, "\\\\\n", sep=" ")
}
}
else
{
latex <- str_c(latex, "\\textbf{Estatística} & \\textbf{Valor} \\\\\n", sep="")
}
latex <- str_c(latex, "\t\t\\hline\n", sep="")
if (col_count > 2)
starting_number <- 2
else
starting_number <- 1
for (i in seq(starting_number, row_count))
{
latex <- str_c(latex, "\t\t", str_flatten(t(data[i,]), collapse = " & "), " \\\\\n")
}
latex <- str_c(latex, "\t\\hline
\t\\end{tabular}
\t\\label{", label, "}
\t\\end{adjustbox}
\\end{quadro}", sep="")
writeLines(latex)
}
View(vector_frequencies)
ggplot(dados, aes(x = dados$LOCAL, y = dados$NOTA_MT, fill = dados$LOCAL)) +
geom_boxplot() +
labs(title = "Boxplot da Proficiência em Matemática por Local",
x = "Local", y = "Proficiência em Matemática")
ggplot(mpg) +
aes(
x = factor(""),
y = cty
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "", y = "Consumo em Cidade (milhas/galão)") +
theme_estat()
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_estat()
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_minimal()
t.test(NOTA_MT ~ LOCAL, data = dados)
ggplot(dados) +
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_minimal()
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_bw()
ggplot(dados, aes(x = dados$NOTA_LP, y = dados$NOTA_MT)) +
geom_jitter(colour = "lightblue", size = 3) +
labs(
x = "Consumo em Cidade (milhas/galão)",
y = "Consumo em Rodovias (milhas/galão)"
) +
theme_bw()
ggplot(dados, aes(x = dados$NOTA_LP, y = dados$NOTA_MT)) +
geom_jitter(colour = "lightblue", size = 3) +
labs(
x = "Notas em Português",
y = "Notas em Matemática"
) +
theme_bw()
t.test(NOTA_MT ~ LOCAL, data = dados)
# 10. Associação entre notas de Língua Portuguesa e Matemática
cor.test(dados$NOTA_LP, dados$NOTA_MT)
# Definir classes para agrupar os dados
classes <- seq(floor(min(dados$NOTA_LP)), ceiling(max(dados$NOTA_LP)), by = 5)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Calcular frequências esperadas assumindo normalidade
n <- length(dados$NOTA_LP)
media <- mean(dados$NOTA_LP)
desvio <- sd(dados$NOTA_LP)
# Probabilidades esperadas para cada intervalo
probs <- pnorm(classes, mean = media, sd = desvio)
probs <- diff(probs)  # Probabilidades para cada classe
# Frequências esperadas
freq_esp <- probs * n
# Aplicar o teste qui-quadrado
chisq.test(freq_obs, p = probs, rescale.p = TRUE)
# Definir classes para agrupar os dados
classes <- seq(min(dados$NOTA_LP), max(dados$NOTA_LP), by = 5)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Calcular frequências esperadas assumindo normalidade
n <- length(dados$NOTA_LP)
media <- mean(dados$NOTA_LP)
desvio <- sd(dados$NOTA_LP)
# Probabilidades esperadas para cada intervalo
probs <- pnorm(classes, mean = media, sd = desvio)
probs <- diff(probs)  # Probabilidades para cada classe
# Frequências esperadas
freq_esp <- probs * n
# Aplicar o teste qui-quadrado
chisq.test(freq_obs, p = probs, rescale.p = TRUE)
# Definir classes para agrupar os dados
classes <- seq(min(dados$NOTA_LP), max(dados$NOTA_LP), by = 20)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Aplicar o teste qui-quadrado
chisq.test(freq_obs, p = probs, rescale.p = TRUE)
classes <- seq(min(dados$NOTA_LP), max(dados$NOTA_LP), by = 20)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Calcular frequências esperadas assumindo normalidade
n <- length(dados$NOTA_LP)
media <- mean(dados$NOTA_LP)
desvio <- sd(dados$NOTA_LP)
# Probabilidades esperadas para cada intervalo
probs <- pnorm(classes, mean = media, sd = desvio)
probs <- diff(probs)  # Probabilidades para cada classe
# Frequências esperadas
freq_esp <- probs * n
# Aplicar o teste qui-quadrado
chisq.test(freq_obs, p = probs, rescale.p = TRUE)
ic_portugues <- t.test(dados$NOTA_LP, conf.level = 1 - alpha)
ic_matematica <- t.test(dados$NOTA_LP, conf.level = 1 - alpha)
# Intervalo de confiança de 95% para as proporções das frequências observadas
ic_freq_obs <- prop.test(freq_obs, n, conf.level = 1 - alpha)
# Exibir os resultados
list(
Teste_Chi_Quadrado = teste_chi,
IC_Media_Portugues = ic_portugues$conf.int,
IC_Media_Matematica = ic_matematica$conf.int,
IC_Frequencias_Observadas = ic_freq_obs$conf.int
)
# Aplicar o teste qui-quadrado
teste_chi =chisq.test(freq_obs, p = probs, rescale.p = TRUE)
# Exibir os resultados
list(
Teste_Chi_Quadrado = teste_chi,
IC_Media_Portugues = ic_portugues$conf.int,
IC_Media_Matematica = ic_matematica$conf.int,
IC_Frequencias_Observadas = ic_freq_obs$conf.int
)
# Definir classes para agrupar os dados
classes <- seq(min(dados$NOTA_LP), max(dados$NOTA_LP), by = 20)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Calcular frequências esperadas assumindo normalidade
n <- length(dados$NOTA_LP)
media <- mean(dados$NOTA_LP)
desvio <- sd(dados$NOTA_LP)
# Probabilidades esperadas para cada intervalo
probs <- pnorm(classes, mean = media, sd = desvio)
probs <- diff(probs)  # Probabilidades para cada classe
# Frequências esperadas
freq_esp <- probs * n
# Aplicar o teste qui-quadrado
teste_chi =chisq.test(freq_obs, p = probs, rescale.p = TRUE)
ic_portugues <- t.test(dados$NOTA_LP, conf.level = 1 - alpha)
alpha= 0,05
alpha= 0.05
# Definir classes para agrupar os dados
classes <- seq(min(dados$NOTA_LP), max(dados$NOTA_LP), by = 20)
# Tabela de frequências observadas
freq_obs <- table(cut(dados$NOTA_LP, breaks = classes))
# Calcular frequências esperadas assumindo normalidade
n <- length(dados$NOTA_LP)
media <- mean(dados$NOTA_LP)
desvio <- sd(dados$NOTA_LP)
# Probabilidades esperadas para cada intervalo
probs <- pnorm(classes, mean = media, sd = desvio)
probs <- diff(probs)  # Probabilidades para cada classe
# Frequências esperadas
freq_esp <- probs * n
# Aplicar o teste qui-quadrado
teste_chi =chisq.test(freq_obs, p = probs, rescale.p = TRUE)
ic_portugues <- t.test(dados$NOTA_LP, conf.level = 1 - alpha)
ic_matematica <- t.test(dados$NOTA_LP, conf.level = 1 - alpha)
# Intervalo de confiança de 95% para as proporções das frequências observadas
ic_freq_obs <- prop.test(freq_obs, n, conf.level = 1 - alpha)
# Exibir os resultados
list(
Teste_Chi_Quadrado = teste_chi,
IC_Media_Portugues = ic_portugues$conf.int,
IC_Media_Matematica = ic_matematica$conf.int,
IC_Frequencias_Observadas = ic_freq_obs$conf.int
)
# Intervalo de confiança de 95% para as proporções das frequências observadas
ic_freq_obs <- prop.test(freq_obs, n, conf.level = 1 - alpha)
View(teste_chi)
rm(list=ls())
source("rdocs/source/packages.R")
dados<-read_excel("C:/Users/DESKTOP/Downloads/Amostra_g09_FelipeBretas_Renan_Tales_VictorSouza.xlsx")
dados<-read_excel("C:/Users/DESKTOP/Downloads/Amostra_g09_FelipeBretas_Renan_Tales_VictorSouza.xlsx")
library(readxl)
library(dplyr)
library(ggplot2)
library(tidyr)
library(psych)
dados<-read_excel("C:/Users/DESKTOP/Downloads/Amostra_g09_FelipeBretas_Renan_Tales_VictorSouza.xlsx")
dados50 <- dados[c(198, 196, 190, 189, 186, 173, 171, 169, 167,
154,147, 145, 144, 143, 141, 139, 132, 127,
117, 116, 111 , 99, 98, 96, 95, 90, 88, 79,
78, 77, 68,65,63, 60, 55, 52, 51, 48, 37, 35,
33, 31, 21, 19, 17, 13, 12, 8, 7, 6),]
t.test(NOTA_MT ~ LOCAL, data = dados)
t.test(NOTA_MT~ LOCAL, data = dados50)
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_bw()
# 7. Diferença significativa entre notas de Língua Portuguesa e Matemática
t.test(dados$NOTA_LP, dados$NOTA_MT, paired = TRUE)
t.test(dados50$NOTA_LP, dados50$NOTA_MT, paired = TRUE)
variancia_lp <- var(dados$NOTA_LP, na.rm = TRUE)
variancia_mt <- var(dados$NOTA_MT, na.rm = TRUE)
ggplot(mpg) +
aes(
x = trans,
y = cty
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Transmissão", y = "Consumo em Cidade (milhas/galão)") +
theme_estat()
# 10. Associação entre notas de Língua Portuguesa e Matemática
cor.test(dados$NOTA_LP, dados$NOTA_MT)
cor.test(dados50$NOTA_LP, dados50$NOTA_MT)
ggplot(dados, aes(x = dados$NOTA_LP, y = dados$NOTA_MT)) +
geom_jitter(colour = "lightblue", size = 3) +
labs(
x = "Notas em Português",
y = "Notas em Matemática"
) +
theme_bw()
setwd("C:/Users/DESKTOP/Downloads/Trabai")
novo= pivot_longer(dados, cols = c("NOTA_LP", "NOTA_MT"),
names_to = "Disciplina", values_to = "Nota")
View(novo)
ggplot(novo) +
aes(
x = novo$Disciplina,
y = novo$Nota
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Transmissão", y = "Consumo em Cidade (milhas/galão)") +
theme_estat()
ggplot(novo) +
aes(
x = novo$Disciplina,
y = novo$Nota
) +
geom_boxplot(fill = c("#A11D21"), width = 0.5) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Transmissão", y = "Consumo em Cidade (milhas/galão)") +
theme_minimal()
ggplot(novo) +
aes(
x = novo$Disciplina,
y = novo$Nota
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Transmissão", y = "Consumo em Cidade (milhas/galão)") +
theme_bw()
# 7. Diferença significativa entre notas de Língua Portuguesa e Matemática
t.test(dados$NOTA_LP, dados$NOTA_MT, paired = TRUE)
source("rdocs/victor.R")
## Baixando o tinytex
library(tinytex)
#tinytex::install_tinytex()
install_tinytex()
tinytex::install_tinytex()
ggplot(dados) +
aes(
x =dados$LOCAL,
y = dados$NOTA_MT
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
guides(fill = FALSE) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Local", y = "Nota em Matemática") +
theme_bw()
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
tidyverse, data.table,
readxl, readr, ggcorrplot, cowplot,
RColorBrewer, scales, nortest, xlsx,
skimr,xtable,geobr,sf,ggrepel,
abjutils,grDevices
)
#windowsFonts(Arial=windowsFont("sans"))
options(scipen=999)
options(OutDec = ",")
# Definindo função que retorna frequências relativas de um vetor
percent <- function(absolute, digits = 2) {
return(round(100 * absolute / sum(absolute), digits))
}
# Definindo função que retorna banco de dados com frequências
# relativas e absolutas de uma variável categórica
vector_frequencies <- function(vector) {
frequency <- vector %>%
table() %>%
as_tibble() %>%
mutate(
rel = n %>%
percent() %>%
paste("%", sep = "")
)
colnames(frequency) <- c("groups", "absolute", "relative")
return(frequency)
}
quadro <- function(dados,t=T){
rn=F
dados <- dados %>%
select_if(is.numeric)
tabela <- skim(dados)
tabela <- as.data.frame(tabela)
tabela <- tabela %>%
select(!c(1,3:4,12)) %>%
mutate(
numeric.mean = round(numeric.mean,2),
numeric.sd = round(numeric.sd,2),
numeric.p0 = round(numeric.p0,2),
numeric.p25 = round(numeric.p25,2),
numeric.p50 = round(numeric.p50,2),
numeric.p75 = round(numeric.p75,2),
numeric.p100 = round(numeric.p100,2),
di = numeric.p75-numeric.p25,
di = round(di,2)
)
colnames(tabela) <- c("Categoria",
"Média","Desvio padrão",
"Mínimo","q25","Mediana","q75","Máximo","D I")
if (t == T){
tabela <- as.data.frame(t(tabela))
colnames(tabela) <- tabela[1,]
tabela <- tabela[-1,]
rn=T
}
tabela <- tabela %>%
mutate_if(is.character, function(x) {
as.numeric(x)
})
tabela <- tabela %>%
mutate_if(is.numeric, function(x) {
format(x, decimal.mark = ",")
})
print(xtable(tabela, type = "latex"), include.rownames=rn)
}
# Remover eixos do gráfico coroplético
no_axis <- theme(axis.title=element_blank(),
axis.text=element_blank(),
axis.ticks=element_blank())
## Nova função de quadro resumo
print_quadro_resumo <- function(data, var_name, title="Medidas resumo da(o) [nome da variável]", label="quad:quadro_resumo1")
{
var_name <- substitute(var_name)
data <- data %>%
summarize(`Média` = round(mean(!!sym(var_name)),2),
`Desvio Padrão` = round(sd(!!sym(var_name)),2),
`Variância` = round(var(!!sym(var_name)),2),
`Mínimo` = round(min(!!sym(var_name)),2),
`1º Quartil` = round(quantile(!!sym(var_name), probs = .25),2),
`Mediana` = round(quantile(!!sym(var_name), probs = .5),2),
`3º Quartil` = round(quantile(!!sym(var_name), probs = .75),2),
`Máximo` = round(max(!!sym(var_name)),2)) %>%
t() %>%
as.data.frame() %>%
rownames_to_column()
latex <- str_c("\\begin{quadro}[H]
\t\\setlength{\t\\tabcolsep}{9pt}
\t\\renewcommand{\t\\arraystretch}{1.20}
\t\\caption{", title, "}
\t\\centering
\t\\begin{adjustbox}{max width=\\textwidth}
\t\\begin{tabular} {", sep="")
col_count <- ncol(data)
row_count <- nrow(data)
latex <- str_c(latex, "| l |\n", sep=" ")
for (i in seq(2, col_count))
{
numCount <- data[i, -c(1)] %>%
as.numeric() %>%
{floor(log10(.)) + 1} %>%
max()
latex <- str_c(latex, "\t\t\tS[table-format = ", numCount ,".2]\n", sep="")
}
latex <- str_c(latex, "\t\t\t|}\n\t\\hline\n\t\t", sep="")
if (col_count > 2)
{
for (i in seq(1,col_count))
{
if (i == 1)
latex <- str_c(latex, "\\textbf{Estatística}", sep="")
else
latex <- str_c(latex, " \\textbf{", data[1, i], "}", sep="")
if (i < col_count)
latex <- str_c(latex, "&", sep=" ")
else
latex <- str_c(latex, "\\\\\n", sep=" ")
}
}
else
{
latex <- str_c(latex, "\\textbf{Estatística} & \\textbf{Valor} \\\\\n", sep="")
}
latex <- str_c(latex, "\t\t\\hline\n", sep="")
if (col_count > 2)
starting_number <- 2
else
starting_number <- 1
for (i in seq(starting_number, row_count))
{
latex <- str_c(latex, "\t\t", str_flatten(t(data[i,]), collapse = " & "), " \\\\\n")
}
latex <- str_c(latex, "\t\\hline
\t\\end{tabular}
\t\\label{", label, "}
\t\\end{adjustbox}
\\end{quadro}", sep="")
writeLines(latex)
}
daods %>% group_by(dados$LOCAL) %>% print_quadro_resumo(var_name = dados$NOTA_MT )
dados %>% group_by(dados$LOCAL) %>% print_quadro_resumo(var_name = dados$NOTA_MT )
dados %>% group_by(LOCAL) %>% print_quadro_resumo(var_name = NOTA_MT )
ggplot(novo) +
aes(
x = novo$Disciplina,
y = novo$Nota
) +
geom_boxplot(fill = c("lightblue"), width = 0.5) +
stat_summary(
fun = "mean", geom = "point", shape = 23, size = 3, fill = "white"
) +
labs(x = "Transmissão", y = "Consumo em Cidade (milhas/galão)") +
theme_bw()
ggplot(dados, aes(x = dados$NOTA_LP, y = dados$NOTA_MT)) +
geom_jitter(colour = "lightblue", size = 3) +
labs(
x = "Notas em Português",
y = "Notas em Matemática"
) +
theme_bw()
